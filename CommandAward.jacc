// To compile and run this program using jacc and Sun's JDK:
//
//    jacc ConfigAwardCommand.jacc
//    javac ConfigCommand.java ConfigTokens.java
//    java  Main
//     ... enter arithmetic expressions ... hit EOF to terminate
//

%{
  import java.io.BufferedReader;
  import java.io.InputStreamReader;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;


  class Rule {
      private String command;
      private String ruleName;
      private AwardFlow awardFlow;
      private MatchCondition matchCondition;

      Rule(Object command, Object ruleName,Object matchCondition, Object awardFlow) {
          this((String) command, (String) ruleName, (MatchCondition)matchCondition,(AwardFlow) awardFlow);
      }

      Rule(String command, String ruleName, MatchCondition matchCondition, AwardFlow awardFlow) {
          this.command = command;
          this.ruleName = ruleName;
          this.matchCondition = matchCondition;
          this.awardFlow = awardFlow;
          System.out.println(command + " " + " " + ruleName + " " + matchCondition + " " + awardFlow);
      }

  }

  class MatchCondition {
      private UserIds userIds;
      MatchCondition(Object userIds){
          this.userIds = (UserIds)userIds;
      }
  }

  class UserIds{
      private List<String> userIds = new ArrayList();

      UserIds(Object num){
          userIds.add(String.valueOf(num));
      }

      UserIds(Object userIds,Object num){
          this.userIds.addAll(((UserIds)userIds).userIds);
          this.userIds.add(String.valueOf(num));
      }

  }

  class AwardFlow {
      private List<Award> awards = new ArrayList<Award>();

      AwardFlow(Object award1, Object award2) {
          awards.addAll(((AwardFlow) award1).awards);
          awards.add((Award) award2);
      }

      AwardFlow(Object award) {
          awards.add((Award) award);
      }

  }

  class Award {
      private String awardName;
      private Integer num;

      Award(Object awardName, Object num) {
          this((String) awardName, (Integer) num);
      }

      Award(String awardName, Integer num) {
          this.awardName = awardName;
          this.num = num;
      }
  }

  class CommandLexer implements CommandTokens {

        private static final Pattern whiteSpacePattern = Pattern.compile("^\\s");
        private static final Pattern identifierPattern = Pattern.compile("^[a-zA-Z]+(\\w|-|)*");
        private static final Pattern numPattern = Pattern.compile("^\\d+");
        private static final Pattern semiColonPattern = Pattern.compile("^;|\\(|\\)|:");


        private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        private String command;

        void readCommand() {
            try {
                command = reader.readLine();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        private int token;
        private Object yylval;

        /**
         * Read the next token and return the
         * corresponding integer code.
         */
        int nextToken() {
            System.out.println(command);
            Matcher identifierMatcher = identifierPattern.matcher(command);
            if (identifierMatcher.find()) {
                yylval = identifierMatcher.group();
                command = command.substring(identifierMatcher.end());
                return token = IDENTIFIER;
            }

            Matcher numMatcher = numPattern.matcher(command);
            if (numMatcher.find()) {
                yylval = Integer.valueOf(numMatcher.group());
                command = command.substring(numMatcher.end());
                return token = NUM;
            }

            Matcher whitespaceMatcher = whiteSpacePattern.matcher(command);
            if (whitespaceMatcher.find()) {
                yylval = whitespaceMatcher.group();
                command = command.substring(whitespaceMatcher.end());
                return token = WHITESPACE;
            }

            Matcher semiColonMatcher = semiColonPattern.matcher(command);
            if (semiColonMatcher.find()) {
                yylval = semiColonMatcher.group().charAt(0);
                command = command.substring(semiColonMatcher.end());
                return token = semiColonMatcher.group().charAt(0);
            }

            return ENDINPUT;
        }

        /**
         * Return the token code for the current lexeme.
         */
        int getToken() {
            return token;
        }

        /**
         * Return the semantic value for the current lexeme.
         */
        Object getSemantic() {
            return yylval;
        }
    }

  class Main {
      public static void main(String[] args) {
          CommandLexer lexer = new CommandLexer();
          lexer.readCommand();
          lexer.nextToken();
          CommandParser parser = new CommandParser(lexer);
          parser.parse();
      }

      static void error(String msg) {
          System.out.println("ERROR: " + msg);
          System.exit(1);
      }
  }

%}

%package   cn.boxfish.jack.parser
%class     CommandParser
%interface CommandTokens
%token ';' '(' ')' ':' IDENTIFIER WHITESPACE NUM

%%

prog  : command WHITESPACE rulename WHITESPACE matchCondition WHITESPACE awardflow    { $$ = new Rule($1,$3,$5,$7); }
      ;
command : IDENTIFIER
        ;
rulename : IDENTIFIER
         ;
matchCondition : '(' userIds ')'            { $$ = new MatchCondition($2); }
               ;
userIds : userIds ':' NUM                   { $$ = new UserIds($1,$3); }
        | NUM                               { $$ = new UserIds($1); }
        ;
awardflow : awardflow ';' award             { $$ = new AwardFlow($1,$3); }
          | award                       { $$ = new AwardFlow($1); } 
          ;    
award : IDENTIFIER WHITESPACE NUM            { $$ = new Award($1,$3); }
      ;
%%

  private CommandLexer lexer;

  CommandParser(CommandLexer lexer) { this.lexer = lexer; }

  private void yyerror(String msg) {
    Main.error(yyerrno<0 ? msg : yyerrmsgs[yyerrno]);
  }